分布式系统中唯一ID的生成方法（文章地址：http://blog.jobbole.com/110064/）

0.在一个存在多个shard的分布式系统中，所生成的全局的uniqueID要满足以下需求：
	1.确保生成的ID全局唯一；
	2.数据在多个shard间迁移，不会受ID生成的方式限制；
	3.生成的ID的中最好带上时间信息，例如ID的前K位是Timestamp，这样能够直接通过对ID的前K位的排序来对数据按时间排序；
	4.生成的ID最好不大于64bits；
	5.生成ID的速度有要求；
	6.整个服务最好没有单点；

20170710
1.ID生成核心需求：
	1.1.记录标识全局唯一；
	1.2.趋势有序；
2.常见方法、不足与优化：
	2.1.使用数据库auto_increment自增id来生成全局唯一ID；
	优点：
		1.简单，使用数据库现有功能；
		2.能够保证唯一性；
		3.能够保证递增性；
		4.步长固定；
	缺点：
		1.可用性难以保证，数据库常见的架构是主从+读写分离，生成ID是写请求，可用性无法保证；
		2.扩展性差，性能有上限，写入是单点，数据库主库的写性能决定ID生成的性能，难以扩展；
	优化：
		1.冗余主库，避免单点写入；
		2.数据水平切分，保证各主库生成的ID不重复；
		3.缺点：无法保证ID的“绝对递增性”，写库压力仍然很大；
	
	2.2.单点批量生成ID服务：数据库使用双master保证可用性，数据库中只保存当前ID的最大值；
		优点：
			1.保证ID生成的绝对递增有序；
			2.批量生成，大大降低了数据库压力；
		缺点：
			1.服务单点；
			2.可能会出现数据空洞，服务重启后ID从下一个最大值开始，之前的ID可能会出现缺失；
			3.性能还是有上限，无法水平扩展；
		优化：使用备用服务，对外提供的服务是主服务，有一个影子服务时刻处于备用状态，当主服务挂了，由备用服务顶上，这个切换过程对于调用方是透明的，通常使用vip+keepalived实现；
	
	2.3.uuid/guid：本地生成ID方式；
		优点：
			1.本地生成ID，不需要远程调用，时延低；
			2.扩展性好，基本认为没有性能上限；
		缺点：
			1.无法保证递增趋势；
			2.uuid过长，通常使用字符串表示，作为数据库主键建立索引查询效率低，常用的优化方案是”转换为俩个uint64整数存储“或”折半存储“（折半后不能保证唯一性）；
	
	2.4.取当前毫秒数：
		优点：
			1.本地生成ID，无需远程调用，时延低；
			2.生成的ID呈递增趋势；
			3.生成的ID是整数，建立索引后查询效率高；
		缺点：
			1.并发量大时，无法保证ID的唯一性；
	
	2.5.类snowflake算法：
		1.核心思想：一个long型的ID，
			• 41bit作为毫秒数；
			• 10bit作为机器编号：
			• 12bit作为毫秒内序列号；

